static class GUIGlobal {
  static Layer root;
  static Pressable dragging;
  static KeyboardListener focusing;
}

class Layer {
  // so that you can group components. 
  public ArrayList<Layer> children;
  private boolean visibility;
  public PVector _translate;
  public PVector _scale;

  public Layer() {
    visibility = true;
    children = new ArrayList<Layer>();
    _translate = new PVector(0f, 0f);
    _scale = new PVector(1f, 1f);
  }
  public boolean isVisible() {
    return visibility;
  }
  void show() {
    visibility = true;
  }
  void hide() {
    visibility = false;
  }
  void draw() {
    pushMatrix();
    translate(_translate.x, _translate.y);
    scale(_scale.x, _scale.y);
    for (Layer child : children) {
      if (child.isVisible()) {
        child.draw();
      }
    }
    popMatrix();
  }
}

static class Pressable extends Layer {
  static int last_drag_x, last_drag_y;
  void hide() {
    super.hide();
    if (GUIGlobal.dragging == this) {
      onRelease();
      GUIGlobal.dragging = null;
    }
  }
  boolean beingDragged() {
    return GUIGlobal.dragging == this;
  }
  boolean isMouseOver() {
    return false;   // to override
  }
  void onPress() {
  }
  void onDrag(int delta_x, int delta_y) {
  }
  void onRelease() {
  }
  void onClick() {
  }
}

void mousePressed() {
  handleMousePress(root);
}

void handleMousePress(Layer layer) {  // recursively broadcast event
  for (Layer child : layer.children) {
    if (child instanceof Pressable) {
      if (child.isVisible() && child.isMouseOver()) {
        child.onPress();
        Pressable.GUIGlobal.dragging = child;
        Pressable.last_drag_x = mouseX;
        Pressable.last_drag_y = mouseY;
        break;
      }
    } else {
      handleMousePress(child);
    }
  }
}

void mouseDragged() {
  if (Pressable.GUIGlobal.dragging != null) {
    Pressable.GUIGlobal.dragging.onDrag(
      mouseX - Pressable.last_drag_x, 
      mouseY - Pressable.last_drag_y);
    Pressable.last_drag_x = mouseX; 
    Pressable.last_drag_y = mouseY;
  }
}

void mouseReleased() {
  if (Pressable.GUIGlobal.dragging != null) {
    Pressable.GUIGlobal.dragging.onRelease();
    if (Pressable.GUIGlobal.dragging.isMouseOver()) {
      Pressable.GUIGlobal.dragging.onClick();
    }
    Pressable.GUIGlobal.dragging = null;
  }
}

static class KeyboardListener extends Layer {
  static KeyboardListener focusing;
  static {
    focusing = null;
  }
  void focus() {
    focusing = this;
  }
  void unfocus() {
    focusing = null;
  }
  boolean hasFocus() {
    return focusing == this;
  }
  void hide() {
    super.hide();
    if (focusing == this) {
      focusing = null;
    }
  }
  void onKeypress(int key_code) {
  }
}

void keyPressed() {
  if (KeyboardListener.focusing != null) {
    KeyboardListener.focusing.onKeypress(keyCode);
  }
}

class Button extends Pressable {
  int x, y, _width, _height;
  String _text; 
  int fontsize;
  color back;
  color fore;
  color highlight;
  int press_sink_depth;
  private boolean floating;
  private float float_progress;

  public Button(String _text, int x, int y, int _width, int _height) {
    this._text = _text;
    this.x = x;
    this.y = y;
    this._width = _width;
    this._height = _height;
    fontsize = 30;
    back = #000000;
    fore = #FFFFFF;
    highlight = #005555;
    press_sink_depth = 5;
    floating = false;
  }

  public Button() {
    this("", 0, 0, 100, 100);
  }

  void draw() {
    stroke(fore);
    strokeWeight(2);
    if (isMouseOver()) {
      fill(highlight);
    } else {
      fill(back);
    }
    pushMatrix();
    if (beingDragged()) {
      translate(press_sink_depth, press_sink_depth);
      floating = true;
      float_progress = press_sink_depth;
    } else {
      if (floating) {
        float_progress *= .8;
        if (float_progress < 1) {
          floating = false;
        } else {
          translate(float_progress, float_progress);
        }
      }
    }
    rect(x, y, _width, _height);
    textSize(fontsize);
    fill(fore);
    textAlign(CENTER, CENTER);
    text(_text, x, y - fontsize/8, _width, _height);
    popMatrix();
  }

  boolean isMouseOver() {
    return x<mouseX && mouseX<x+_width 
      && y<mouseY && mouseY<y+_height;
  }
}

class Slider extends KeyboardListener {
  class Arrow extends Button {
    Slider parent;
    public Arrow(Slider parent, String left_or_right) {
      this.parent = parent;
      fontsize = 36;
      if (left_or_right == "<") {
        _text = "<";
        x = parent.x;
      } else {
        _text = ">";
        x = parent.x + parent._width - parent._height;
      }
      y = parent.y;
      _width = parent._height;
      _height = parent._height;
    }

    void onClick() {
      parent.arrowClick(_text);
    }
  }
  class Box extends Button {
    Slider parent;
    Color colorFocused;
    float hint_fontsize_ratio;

    public Box(Slider parent) {
      this.parent = parent;
      _width = 100;
      fontsize = 30;
      fore = #FFFFFF;
      back = #000000;
      highlight = #005555;
      colorFocused = #0000cc;
      hint_fontsize_ratio = .6;
    }
    void onPress() {
      if (parent.hasFocus()) return;
      clicked_or_dragged = true;
    }
    void onDrag(int delta_x, int delta_y) {
      if (hasFocus()) return;
      clicked_or_dragged = false;
      value += (float)delta_x / slideSpace() * (_max - _min);
      legalizeValue();
    }
    void onRelease() {
      if (hasFocus()) return;
      value = int(value);
      legalizeValue();
      onChange();
    }
    void onClick() {
      if (hasFocus()) return;
      if (clicked_or_dragged) {
        focus();
        input_value = "";
      }
    }
    void draw() {
      x = parent.boxX();
      strokeWeight(2);
      if (parent.hasFocus()) {
        fill(colorFocused);
        stroke(fore);
      } else if (beingDragged()) {
        fill(fore);
        stroke(back);
      } else if (isMouseOver()) {
        fill(highlight);
        stroke(fore);
      } else {
        fill(back);
        stroke(fore);
      }
      rect(x, parent.y, _width, parent._height);
      fill(g.strokeColor);
      textSize(fontsize);
      textAlign(CENTER, CENTER);
      String to_draw;
      if (parent.hasFocus()) {
        if (input_value.length() == 0) {
          to_draw = "Type!";
          textSize(fontsize * hint_fontsize_ratio);
        } else {
          to_draw = input_value;
        }
      } else {
        to_draw = String.valueOf(parent.getValue());
      }
      text(to_draw, x, parent.y - fontsize/8, _width, parent._height);
    }
  }
  class Rail extends Layer {
    color stroke_color;
    int thick;
    Slider parent;
    Rail(Slider parent) {
      this.parent = parent;
      stroke_color = #FFFFFF;
      thich = 2;
    }
    void draw() {
      stroke(stroke_color);
      strokeWeight(thick);
      line(parent.x + parent._height, parent.y + parent._height/2, 
        parent.x + parent._width - parent._height, parent.y + parent._height/2);
    }
  }
  private int x, y, _width, _height;
  int _min, _max;
  private float value;
  Arrow leftArrow, rightArrow;
  Box box;
  Rail rail;
  private boolean clicked_or_dragged;
  private String input_value;

  public Slider(int x, int y, int _width, int _height) {
    this.x = x;
    this.y = y;
    this._width = _width;
    this._height = _height;
    _min = 0; 
    _max = 100;
    value = _max;
    leftArrow = new Arrow(this, "<");
    rightArrow = new Arrow(this, ">");
    box = new Box(this);
    rail = new Rail();
    this.children.add(rail);
    this.children.add(box);
    this.children.add(leftArrow);
    this.children.add(rightArrow);
  }

  void setValue(int new_value) {
    value = new_value;
    legalizeValue();
    onChange();
  }

  private void arrowClick(String left_or_right) {
    if (hasFocus()) return;
    if (left_or_right == "<") {
      value --;
    } else {
      // >
      value ++;
    }
    legalizeValue();
    onChange();
  }

  private void legalizeValue() {
    if (value < _min) value = _min;
    if (value > _max) value = _max;
  }

  private int slideSpace() {
    return _width - 2*_height - box._width;
  }

  int getValue() {
    return int(value);
  }

  void onKeypress(int key_code) {
    if (key_code == 10) {
      // Enter
      unfocus();
      if (input_value.length() != 0) {
        value = Integer.parseInt(input_value);
        legalizeValue();
        onChange();
      }
    } else if (48 <= key_code && key_code < 58
      || 96 <= key_code && key_code < 106) {
      // Number
      input_value += key;
    } else if (key_code == 8) {
      // Backspace
      if (input_value.length() > 0) {
        input_value = input_value.
          substring(0, input_value.length() - 1);
      }
    }
  }

  void onChange() {
    ; // event. To override.
  }

  private int boxX() {
    float proportion = ((float)(value - _min)) 
      / (_max - _min);
    return int(slideSpace() * proportion) + x + _height;
  }
}
